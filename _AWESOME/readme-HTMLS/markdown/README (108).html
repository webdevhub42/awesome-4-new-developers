<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README (108)</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="jquery-tippek-amiket-mindenkinek-tudni-érdemes-awesome">jQuery tippek, amiket mindenkinek tudni érdemes <a href="https://github.com/sindresorhus/awesome"><img src="https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg" alt="Awesome" /></a></h1>
<p>Egyszerű tippek gyűjteménye, a jQuery-ben való elmélyülésed segítendő.</p>
<blockquote>
<p>További nagyszerű listákért tekintsd meg <span class="citation" data-cites="sindresorhus">[<span class="citation" data-cites="sindresorhus">@sindresorhus</span>]</span>(https://github.com/sindresorhus/) válogatott <a href="https://github.com/sindresorhus/awesome/">listáját</a>.</p>
</blockquote>
<h2 id="tartalomjegyzék">Tartalomjegyzék</h2>
<ul>
<li><a href="#tippek">Tippek</a></li>
<li><a href="#t%C3%A1mogat%C3%A1s">Támogatás</a></li>
<li><a href="../../CONTRIBUTING.md">Közreműködési útmutató (angolul)</a></li>
</ul>
<h2 id="tippek">Tippek</h2>
<ol type="1">
<li><a href="#használat-noconflict">Használat <code>noConflict()</code></a></li>
<li><a href="#bet%C3%B6lt%C3%B6tt-e-a-jquery---ellen%C5%91rz%C3%A9s">Betöltött-e a jQuery? - Ellenőrzés</a></li>
<li><a href="#ellenőrizze,-hogy-van-e-elem">Ellenőrizze, hogy van-e elem</a></li>
<li><a href="#on-binding-k%C3%B6t%C3%A9s-haszn%C3%A1lata-click-helyett"><code>.on()</code> binding (“kötés”) használata <code>.click()</code> helyett</a></li>
<li><a href="#vissza-az-elej%C3%A9re-gomb">‘Vissza az elejére’ gomb</a></li>
<li><a href="#k%C3%A9pek-el%C5%91bet%C3%B6lt%C3%A9se">Képek előbetöltése</a></li>
<li><a href="#bet%C3%B6lt%C3%B6ttek-e-a-k%C3%A9pek---ellen%C5%91rz%C3%A9s">Betöltöttek-e a képek? - Ellenőrzés</a></li>
<li><a href="#bet%C3%B6lthetetlen-k%C3%A9pek-automatikus-jav%C3%ADt%C3%A1sa">Betölt(het)etlen képek automatikus javítása</a></li>
<li><a href="#%C5%B1rlap-elk%C3%BCld%C3%A9se-ajax-al">Űrlap elküldése AJAX-al</a></li>
<li><a href="#css-oszt%C3%A1ly-aktiv%C3%A1l%C3%A1sa-a-kurzor-hat%C3%A1s%C3%A1ra">CSS osztály aktiválása a kurzor hatására</a></li>
<li><a href="#beviteli-mez%C5%91k-kikapcsol%C3%A1sa">Beviteli mezők kikapcsolása</a></li>
<li><a href="#linkbet%C3%B6lt%C3%A9s-meg%C3%A1ll%C3%ADt%C3%A1sa">Linkbetöltés megállítása</a></li>
<li><a href="#jquery-kiv%C3%A1laszt%C3%B3k-elt%C3%A1rol%C3%A1sa">jQuery kiválasztók eltárolása</a></li>
<li><a href="#%C3%A1tt%C5%B1n%C3%A9sbecs%C3%BAsz%C3%A1s-effekt-r%C3%B6gz%C3%ADt%C3%A9se">Áttűnés/becsúszás effekt rögzítése</a></li>
<li><a href="#egyszer%C5%B1-accordion-harmonika-men%C3%BC">Egyszerű accordion (harmonika-menü)</a></li>
<li><a href="#html-div-elemek-egyez%C5%91-magass%C3%A1ggal">HTML div elemek egyező magassággal</a></li>
<li><a href="#k%C3%BCls%C5%91-linkek-megnyit%C3%A1sa-%C3%BAj-f%C3%BCl%C3%B6nablakban">Külső linkek megnyitása új fülön/ablakban</a></li>
<li><a href="#elemek-keres%C3%A9se-sz%C3%B6veg-alapj%C3%A1n">Elemek keresése szöveg alapján</a></li>
<li><a href="#script-aktiv%C3%A1l%C3%A1s-l%C3%A1that%C3%B3s%C3%A1g-v%C3%A1ltoz%C3%A1sa-eset%C3%A9n">Script aktiválás láthatóság változása esetén</a></li>
<li><a href="#ajax-h%C3%ADv%C3%A1sok-hibakezel%C3%A9se">AJAX hívások hibakezelése</a></li>
<li><a href="#plugin-h%C3%ADv%C3%A1sok-l%C3%A1ncol%C3%A1sa">Plugin hívások láncolása</a></li>
<li><a href="#listaelemek-sorba-rendez%C3%A9se-abc-szerint">Listaelemek sorba rendezése ABC szerint</a></li>
<li><a href="#jobb-eg%C3%A9rkattint%C3%A1s-kikapcsol%C3%A1sa">Jobb egérkattintás kikapcsolása</a></li>
</ol>
<h3 id="használat-noconflict">Használat <code>noConflict()</code></h3>
<p>A jQuery által használt <code>$</code> álnevet más JavaScript könyvtárak is használják. Annak érdekében, hogy a jQuery ne ütközzön a különböző könyvtárak <code>$</code> objektumával, használja a <code>noConflict()</code> metódust a dokumentum elején:</p>
<pre><code>jQuery.noConflict();</code></pre>
<p>Most a jQuery objektumra a <code>jQuery</code> változónevet a <code>$</code> (például <code>jQuery('div p')hide()</code>). Ha a jQuery több verziója ugyanazon az oldalon található, akkor a <code>noConflict ()</code> paranccsal adhat meg egy álnevet egy adott verzióhoz:</p>
<pre><code>let $x = jQuery.noConflict();</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="betöltött-e-a-jquery---ellenőrzés">Betöltött-e a jQuery? - Ellenőrzés</h3>
<p>Mielőtt bármihez is kezdhetnél a jQuery-vel, először biztosra kell menned abban, hogy betöltött:</p>
<pre><code>if (typeof jQuery == &#39;undefined&#39;) {
  console.log(&#39;jQuery hasn\&#39;t loaded&#39;);
} else {
  console.log(&#39;jQuery has loaded&#39;);
}</code></pre>
<p>Most, hogy elstartoltunk…</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="ellenőrizze-hogy-van-e-elem">Ellenőrizze, hogy van-e elem</h3>
<p>A HTML elem használata előtt meg kell győződnie arról, hogy része a DOM-nak.</p>
<pre><code>if ($(&quot;#selector&quot;).length) {
  //csinálj valamit az elemmel
}</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="on-binding-kötés-használata-.click-helyett"><code>.on()</code> binding (“kötés”) használata <code>.click()</code> helyett</h3>
<p>Az <code>.on()</code> függvény használata számos előnnyel rendelkezik a <code>.click()</code> megoldással szemben, mint például: több esemény egyszeri hozzáadása…</p>
<pre><code>.on(&#39;click tap hover&#39;)</code></pre>
<p>…a kötés alkalmazása dinamikusan létrehozott elemekre is (tehát nem kell egyesével végrehajtani a kötést minden dinamikus DOM elemre)…</p>
<p>…és a névterek felállításának lehetősége:</p>
<pre><code>.on(&#39;click.menuOpening&#39;)</code></pre>
<p>Névterek segítségével “lecsatolhatsz” egyes konkrét eseményeket (pl. <code>.off('click.menuOpening')</code>).</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="vissza-az-elejére-gomb">‘Vissza az elejére’ gomb</h3>
<p>Hála a jQuery <code>animate</code> és <code>scrollTop</code> eljárásainak, nincs szükséged pluginokra ahhoz, hogy létrehozz egy egyszerű ‘scroll-to-top’ animációt:</p>
<pre><code>// Back to top
$(&#39;.container&#39;).on(&#39;click&#39;, &#39;.back-to-top&#39;, function (e) {
  e.preventDefault();
  $(&#39;html, body&#39;).animate({scrollTop: 0}, 800);
});

&lt;!-- Create an anchor tag --&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;a href=&quot;#&quot; class=&quot;back-to-top&quot;&gt;Back to top&lt;/a&gt;
&lt;/div&gt;</code></pre>
<p>A <code>scrollTop</code> értékének változtatásával beállíthatod, hova szeretnéd, hogy érkezzen a görgetősáv. Igazából amit csinálsz, az annyi, hogy a látható részt animálod egy 800 miliszekundumos időtartamon belül, aminek a végére ez aztán “felgurul” a dokumentum tetejére.</p>
<p><strong>Megjegyzés:</strong> Figyelj oda a <code>scrollTop</code> esetenkénti <a href="https://github.com/jquery/api.jquery.com/issues/417">bugos viselkedésére</a>.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="képek-előbetöltése">Képek előbetöltése</h3>
<p>If your web page uses a lot of images that aren’t visible initially (e.g., on hover) it makes sense to preload them:</p>
<pre><code>$.preloadImages = function () {
  for (var i = 0; i &lt; arguments.length; i++) {
    $(&#39;&lt;img&gt;&#39;).attr(&#39;src&#39;, arguments[i]);
  }
};

$.preloadImages(&#39;img/hover-on.png&#39;, &#39;img/hover-off.png&#39;);</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="betöltöttek-e-a-képek---ellenőrzés">Betöltöttek-e a képek? - Ellenőrzés</h3>
<p>Alkalmanként szükséges lehet rá. hogy leellenőrizd, teljesen betöltöttek-e a képeid, annak érdekében, hogy folytatódhasson a scripted lefutása:</p>
<pre><code>$(&#39;img&#39;).on(&#39;load&#39;, function () {
  console.log(&#39;image load successful&#39;);
});</code></pre>
<p>Ezen felül azt is leellenőrizheted, hogy egy konkrét kép betöltött-e: mindössze cseréld le a fenti kódban az <code>&lt;img&gt;</code> címkét egy megfelelő azonosíra (ID) vagy osztályra.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="betölthetetlen-képek-automatikus-javítása">Betölt(het)etlen képek automatikus javítása</h3>
<p>Ha úgy alakul, hogy ‘törött képlinkeket’ találsz az oldaladon, egyenként mindet lecserélni fájdalmasan hosszú és kimerítő folyamat lenne. Ez az egyszerű kódrészlet sok fejfájástól megkímélhet:</p>
<pre><code>$(&#39;img&#39;).on(&#39;error&#39;, function () {
  if(!$(this).hasClass(&#39;broken-image&#39;)) {
    $(this).prop(&#39;src&#39;, &#39;img/broken.png&#39;).addClass(&#39;broken-image&#39;);
  }
});</code></pre>
<p>Alternatívaként, ha egyszerűen csak el kívánod rejteni ezeket a betölt(het)etlen képeket, ez a kódrészlet gondoskodik róla:</p>
<pre><code>$(&#39;img&#39;).on(&#39;error&#39;, function () {
  $(this).hide();
});</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="űrlap-elküldése-ajax-al">Űrlap elküldése AJAX-al</h3>
<p>A jQuery AJAX eljárások elterjedt módjai szöveges, HTML, XML vagy JSON állományok lekérésének. Ha egy egyszerű űrlapot kívánsz AJAX-on keresztül elküldeni, a felhasználói bemenetet össze tudod gyűjteni a <code>val()</code> eljárás segítségével:</p>
<pre><code>$.post(&#39;sign_up.php&#39;, {
  user_name: $(&#39;input[name=user_name]&#39;).val(),
  email:     $(&#39;input[name=email]&#39;).val(),
  password:  $(&#39;input[name=password]&#39;).val(),
});</code></pre>
<p>A <code>val()</code> hívások ugyanakkor számításigényesek. Felhasználói input begyűjtésére kedvezőbb módszer a <code>serialize()</code> függvény használata, ami ezeket string-ként gyűjti be:</p>
<pre><code>$.post(&#39;sign_up&#39;, $(&#39;#sign-up-form&#39;).serialize());</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="css-osztály-aktiválása-a-kurzor-hatására">CSS osztály aktiválása a kurzor hatására</h3>
<p>Tegyük fel, hogy egy kattintható elem megjelenését szeretnéd megváltoztatni, amikor egy felhasználó a kurzorával éppen fölötte áll. (:hover)</p>
<p>Elemedhez hozzáadhatsz egy vagy több CSS osztályt ilyen esetekben; amikor a felhasználó arrébb viszi a kurzort, az osztály automatikusan eltávolításra kerül az elemről:</p>
<pre><code>$(&#39;.btn&#39;).on(&#39;hover&#39;, function () {
  $(this).addClass(&#39;hover&#39;);
}, function () {
  $(this).removeClass(&#39;hover&#39;);
});</code></pre>
<p>Innentől már csak a szükséges CSS-t kell hozzáadnod. Viszont egy <em>még egyszerűbb</em> módszerért használhatod a <code>toggleClass</code> eljárást is:</p>
<pre><code>$(&#39;.btn&#39;).on(&#39;hover&#39;, function () {
  $(this).toggleClass(&#39;hover&#39;);
});</code></pre>
<p><strong>Megjegyzés:</strong> a CSS gyorsabb megoldás lehet ebben az esetben, mindazonáltal érdemes tudnod róla, hogy ilyet is lehet.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="beviteli-mezők-kikapcsolása">Beviteli mezők kikapcsolása</h3>
<p>Alkalmanként előfordulhat, hogy érdekedben áll kikapcsolni a “küldés” gombot egy űrlapon, vagy letiltani egy vagy több szövegbeviteli mezőt, amíg a felhasználó végre nem hajt egy bizonyos akciót (pl. bepipálja az “elolvastam a felhasználói feltételeket” jelölőnégyzetet). Adj hozzá egy <code>disabled</code> tulajdonságot a beviteli mezőidhez, így kedved szerint (de)aktiválhatod őket:</p>
<pre><code>$(&#39;input[type=&quot;submit&quot;]&#39;).prop(&#39;disabled&#39;, true);</code></pre>
<p>Nem kell mást tenned, mint újra futtatni a <code>prop</code> eljárást az adott beviteli mező(kö)n, ezúttal <code>false</code> értékkel:</p>
<pre><code>$(&#39;input[type=&quot;submit&quot;]&#39;).prop(&#39;disabled&#39;, false);</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="linkbetöltés-megállítása">Linkbetöltés megállítása</h3>
<p>Alkalmanként előfordulhat, hogy egy linkre kattintva nem kívánsz se betölteni egy bizonyos weboldalt, se ugyanazt az oldalt újra, hanem valami másra kell, mint például valami más script aktiválása. Ez a kód megelőzi az alapértelmezett akció lefutását:</p>
<pre><code>$(&#39;a.no-link&#39;).on(&#39;click&#39;, function (e) {
  e.preventDefault();
});</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="jquery-kiválasztók-eltárolása">jQuery kiválasztók eltárolása</h3>
<p>Gondolj bele, milyen sokszor kellett ugyanazt a kiválasztót (selector) leírnod újra meg újra. Minden <code>$('.elem')</code> kiválasztó újra meg újra végig kell böngéssze a teljes DOM-ot akárhányszor meghívod - függetlenül attól, hogy az a kiválasztó egyszer volt-e már futtatva. Szóval helyette futtasd a kiválasztót egyszer, és tárold el az eredményét egy változóban:</p>
<pre><code>var blocks = $(&#39;#blocks&#39;).find(&#39;li&#39;);</code></pre>
<p>Most már használhatod s <code>blocks</code> változót akárhányszor csak akarod, anélkül, hogy a DOM-ot át kelljen böngészni érte:</p>
<pre><code>$(&#39;#hideBlocks&#39;).on(&#39;click&#39;, function () {
  blocks.fadeOut();
});

$(&#39;#showBlocks&#39;).on(&#39;click&#39;, function () {
  blocks.fadeIn();
});</code></pre>
<p>A jQuery kiválasztók eltárolása egy roppant egyszerű teljesítményjavító technika.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="áttűnésbecsúszás-effekt-rögzítése">Áttűnés/becsúszás effekt rögzítése</h3>
<p>A becsúszások és az áttűnések olyan tuajdonságok, amiket előszeretettel használunk animációkhoz a jQuery-ben. Lehet, hogy csak akkor szeretnéd láthatóvá tenni az adott elemet, amikor a felhasználó rákattint valamire, amire a <code>fadeIn</code> és <code>slideDown</code> eljárások tökéletesek. De ha azt szeretnéd, hogy az adott elem első kattintásra felbukkanjon, majd a másodikre eltűnjön, ez pont megfelel a célra:</p>
<pre><code>// Fade
$(&#39;.btn&#39;).on(&#39;click&#39;, function () {
  $(&#39;.element&#39;).fadeToggle(&#39;slow&#39;);
});

// Toggle
$(&#39;.btn&#39;).on(&#39;click&#39;, function () {
  $(&#39;.element&#39;).slideToggle(&#39;slow&#39;);
});</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="egyszerű-accordion-harmonika-menü">Egyszerű accordion (harmonika-menü)</h3>
<p>Íme egy egyszerá eljárás egy egyszerű harmonika-menü elkészítésére:</p>
<pre><code>// Close all panels
$(&#39;#accordion&#39;).find(&#39;.content&#39;).hide();

// Accordion
$(&#39;#accordion&#39;).find(&#39;.accordion-header&#39;).on(&#39;click&#39;, function () {
  var next = $(this).next();
  next.slideToggle(&#39;fast&#39;);
  $(&#39;.content&#39;).not(next).slideUp(&#39;fast&#39;);
  return false;
});</code></pre>
<p>Ezen script hozzáadásával már nincs már feladatot hátra a weboldaladon, mint a szükséges HTML elkészítése ahhoz, hogy ezt működésre bírd.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="html-div-elemek-egyező-magassággal">HTML div elemek egyező magassággal</h3>
<p>Néha szükséged lehet arra, hogy két HTML div elem egyforma magas legyen, függetlenül azok belső tartalmától:</p>
<pre><code>$(&#39;.div&#39;).css(&#39;min-height&#39;, $(&#39;.main-div&#39;).height());</code></pre>
<p>Ez a példa beállít egy <code>min-height</code> értéket, ami azt jelenti, hogy a kiválasztott elemnek megengedjük, hogy a fő div-nél nagyobb legyen, de azt nem, hogy kisebb.</p>
<p>Egy rugalmasabb megoldás ciklusban végigmenni elemek egy adott halmazán, és azok közül a legmagasabbéhoz állítani a kérdéses elem magasságát:</p>
<pre><code>var $columns = $(&#39;.column&#39;);
var height = 0;
$columns.each(function () {
  if ($(this).height() &gt; height) {
    height = $(this).height();
  }
});
$columns.height(height);</code></pre>
<p>Ha <em>minden</em> minden oszop magasságát egyformára akarod:</p>
<pre><code>var $rows = $(&#39;.same-height-columns&#39;);
$rows.each(function () {
  $(this).find(&#39;.column&#39;).height($(this).height());
});</code></pre>
<p><strong>Megjegyzés:</strong> Erre sok megoldás van <a href="http://codepen.io/AllThingsSmitty/pen/KMPqoO">CSS-ben</a> de a szükségleteidtől függően, érdemes lehet tudni, hogyan is megy ez jQuery-ben.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="külső-linkek-megnyitása-új-fülönablakban">Külső linkek megnyitása új fülön/ablakban</h3>
<p>Külső linkek új böngészőfülön vagy -ablakban megnyitása, és annak biztosítása, hogy az azonos forrású linkek ugyanabban a fülben/ablakban nyílnak meg:</p>
<pre><code>$(&#39;a[href^=&quot;http&quot;]&#39;).attr(&#39;target&#39;, &#39;_blank&#39;);
$(&#39;a[href^=&quot;//&quot;]&#39;).attr(&#39;target&#39;, &#39;_blank&#39;);
$(&#39;a[href^=&quot;&#39; + window.location.origin + &#39;&quot;]&#39;).attr(&#39;target&#39;, &#39;_self&#39;);</code></pre>
<p><strong>Megjegyzés:</strong> <code>window.location.origin</code> nem működik IE10-ben. <a href="http://tosbourn.com/a-fix-for-window-location-origin-in-internet-explorer/">Ez a javítás</a> gondoskodik erről a problémáról.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="elemek-keresése-szöveg-alapján">Elemek keresése szöveg alapján</h3>
<p>A jQuery <code>contains()</code> kiválasztójának használatával megtalálhatsz szöveg(részlet)eket egy elem tartalmában. Ez a kód, ha nem talál szöveget az elemben, elrejti azt:</p>
<pre><code>var search = $(&#39;#search&#39;).val();
$(&#39;div:not(:contains(&quot;&#39; + search + &#39;&quot;))&#39;).hide();</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="script-aktiválás-láthatóság-változása-esetén">Script aktiválás láthatóság változása esetén</h3>
<p>Javascript aktiválásra amikor a felhasználó ellapoz egy fülről, vagy visszalép oda:</p>
<pre><code>$(document).on(&#39;visibilitychange&#39;, function (e) {
  if (e.target.visibilityState === &#39;visible&#39;) {
    console.log(&#39;Tab is now in view!&#39;);
  } else if (e.target.visibilityState === &#39;hidden&#39;) {
    console.log(&#39;Tab is now hidden!&#39;);
  }
});</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="ajax-hívások-hibakezelése">AJAX hívások hibakezelése</h3>
<p>Amikor egy AJAX hívás HTTP 404 vagy 500 hibával tér vissza, a hibakezelő végrehajtásra kerül. Ha a hibakezelő nincs definiálva, további jQuery kódok potenciálisan működésképtelenné válnak. Definiálj egy globális AJAX hibakezelőt:</p>
<pre><code>$(document).on(&#39;ajaxError&#39;, function (e, xhr, settings, error) {
  console.log(error);
});</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="plugin-hívások-láncolása">Plugin hívások láncolása</h3>
<p>A jQuery lehetővé teszi plugin eljáráshívások “láncolását” a DOM ismételt lekérése folyamatának enyhítésére, valamint több jQuery objektum létrehozására. Tegyük fel, hogy az alábbi kódtöredék jelképezi a plugin eljáráshívásaid:</p>
<pre><code>$(&#39;#elem&#39;).show();
$(&#39;#elem&#39;).html(&#39;bla&#39;);
$(&#39;#elem&#39;).otherStuff();</code></pre>
<p>Ekkor igen komoly teljesítményövekedést érhetsz el láncolás használatával:</p>
<pre><code>$(&#39;#elem&#39;)
  .show()
  .html(&#39;bla&#39;)
  .otherStuff();</code></pre>
<p>Alternatívaként eltárolhatod az elemet egy változóban (<code>$</code> előtaggal):</p>
<pre><code>var $elem = $(&#39;#elem&#39;);
$elem.hide();
$elem.html(&#39;bla&#39;);
$elem.otherStuff();</code></pre>
<p>Mind a láncolás, mint az <a href="#cache-jquery-selectors">eltárolás</a> eljárásai “legjobb gyakorlatnak” (best practice) tekinthetők jQuery-ben, és rövidebb, gyorsabb kódot eredményeznek.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="listaelemek-sorba-rendezése-abc-szerint">Listaelemek sorba rendezése ABC szerint</h3>
<p>Tegyük fel, hogy egy listádban túl sok elem van. Mondjuk a lista tartalma egy CMS által került legenerálásra, és te szeretnéd ezt ABC-sorba rendezni:</p>
<pre><code>var ul = $(&#39;#list&#39;),
lis = $(&#39;li&#39;, ul).get();

lis.sort(function (a, b) {
  return ($(a).text().toUpperCase() &lt; $(b).text().toUpperCase()) ? -1 : 1;
});

ul.append(lis);</code></pre>
<p>Meg is volnánk!</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h3 id="jobb-egérkattintás-kikapcsolása">Jobb egérkattintás kikapcsolása</h3>
<p>Ha le szeretnéd tiltani a jobb-klikket, az egész oldalra megteheted…</p>
<pre><code>$(document).ready(function () {
  $(document).bind(&#39;contextmenu&#39;, function (e) {
    return false;
  })
})</code></pre>
<p>…de akár egy konkrét elemre is:</p>
<pre><code>$(document).ready(function () {
  $(&#39;#submit&#39;).bind(&#39;contextmenu&#39;, function (e) {
    return false;
  })
})</code></pre>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
<h2 id="támogatás">Támogatás</h2>
<p>A Chrome, Firefox, Safari, Opera, Edge és IE11 böngészők jelenlegi verziói.</p>
<p><sup><a href="#tartalomjegyz%C3%A9k">vissza a tartalomjegyzékhez</a></sup></p>
</body>
</html>
